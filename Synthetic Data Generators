# synthetic_intelligence/data_generators.py
import numpy as np
import pandas as pd
from typing import Dict, Any, List, Tuple
from .si_core import SyntheticDataGenerator, SyntheticDataConfig, SyntheticDataType
from sklearn.datasets import make_classification, make_regression, make_blobs
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
from PIL import Image, ImageDraw
import networkx as nx
from qiskit import QuantumCircuit, execute, Aer
from qiskit.quantum_info import random_statevector
import json
import random
import string

class TabularDataGenerator(SyntheticDataGenerator):
    def generate(self, config: SyntheticDataConfig) -> pd.DataFrame:
        if config.seed is not None:
            np.random.seed(config.seed)
        
        n_samples = config.size
        n_features = config.parameters.get('n_features', 10)
        n_classes = config.parameters.get('n_classes', 2)
        task_type = config.parameters.get('task_type', 'classification')
        
        if task_type == 'classification':
            X, y = make_classification(
                n_samples=n_samples,
                n_features=n_features,
                n_informative=int(n_features * 0.7),
                n_redundant=int(n_features * 0.2),
                n_classes=n_classes,
                random_state=config.seed
            )
        elif task_type == 'regression':
            X, y = make_regression(
                n_samples=n_samples,
                n_features=n_features,
                n_informative=int(n_features * 0.7),
                noise=config.noise_level,
                random_state=config.seed
            )
        else:
            raise ValueError(f"Unsupported task type: {task_type}")
        
        # Create feature names
        feature_names = [f"feature_{i}" for i in range(n_features)]
        
        # Create DataFrame
        df = pd.DataFrame(X, columns=feature_names)
        df['target'] = y
        
        # Add noise if specified
        if config.noise_level > 0:
            noise = np.random.normal(0, config.noise_level, df.shape)
            df.iloc[:, :-1] += noise[:, :-1]
        
        # Add categorical features if specified
        n_categorical = config.parameters.get('n_categorical', 0)
        if n_categorical > 0:
            for i in range(n_categorical):
                cat_name = f"category_{i}"
                categories = config.parameters.get(f'categories_{i}', ['A', 'B', 'C'])
                df[cat_name] = np.random.choice(categories, size=n_samples)
        
        return df

class TimeSeriesGenerator(SyntheticDataGenerator):
    def generate(self, config: SyntheticDataConfig) -> pd.DataFrame:
        if config.seed is not None:
            np.random.seed(config.seed)
        
        n_samples = config.size
        pattern_type = config.parameters.get('pattern_type', 'random_walk')
        seasonality = config.parameters.get('seasonality', False)
        trend = config.parameters.get('trend', False)
        noise_level = config.noise_level
        
        # Generate base time series
        if pattern_type == 'random_walk':
            series = np.cumsum(np.random.normal(0, 1, n_samples))
        elif pattern_type == 'sine':
            t = np.linspace(0, 4*np.pi, n_samples)
            series = np.sin(t)
        elif pattern_type == 'exponential':
            t = np.linspace(0, 1, n_samples)
            series = np.exp(t)
        else:
            series = np.random.normal(0, 1, n_samples)
        
        # Add seasonality
        if seasonality:
            period = config.parameters.get('seasonality_period', 24)
            seasonal_pattern = np.sin(2 * np.pi * np.arange(n_samples) / period)
            series += seasonal_pattern
        
        # Add trend
        if trend:
            trend_slope = config.parameters.get('trend_slope', 0.01)
            series += trend_slope * np.arange(n_samples)
        
        # Add noise
        if noise_level > 0:
            series += np.random.normal(0, noise_level, n_samples)
        
        # Create DataFrame
        df = pd.DataFrame({
            'timestamp': pd.date_range(start='2023-01-01', periods=n_samples, freq='H'),
            'value': series
        })
        
        # Add additional features
        n_features = config.parameters.get('n_features', 0)
        for i in range(n_features):
            feature_type = config.parameters.get(f'feature_type_{i}', 'random')
            if feature_type == 'random':
                df[f'feature_{i}'] = np.random.normal(0, 1, n_samples)
            elif feature_type == 'lag':
                lag = config.parameters.get(f'lag_{i}', 1)
                df[f'feature_{i}'] = df['value'].shift(lag).fillna(method='bfill')
            elif feature_type == 'rolling_mean':
                window = config.parameters.get(f'window_{i}', 5)
                df[f'feature_{i}'] = df['value'].rolling(window).mean().fillna(method='bfill')
        
        return df

class ImageGenerator(SyntheticDataGenerator):
    def generate(self, config: SyntheticDataConfig) -> List:
        if config.seed is not None:
            np.random.seed(config.seed)
            random.seed(config.seed)
        
        n_images = config.size
        image_size = config.parameters.get('image_size', (64, 64))
        image_type = config.parameters.get('image_type', 'random')
        
        images = []
        for _ in range(n_images):
            if image_type == 'random':
                # Random noise
                img_array = np.random.rand(*image_size, 3) * 255
            elif image_type == 'geometric':
                # Geometric shapes
                img = Image.new('RGB', image_size, color='black')
                draw = ImageDraw.Draw(img)
                
                # Random shape
                shape_type = random.choice(['rectangle', 'circle', 'triangle'])
                color = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
                
                if shape_type == 'rectangle':
                    x1 = random.randint(0, image_size[0]//2)
                    y1 = random.randint(0, image_size[1]//2)
                    x2 = random.randint(image_size[0]//2, image_size[0])
                    y2 = random.randint(image_size[1]//2, image_size[1])
                    draw.rectangle([x1, y1, x2, y2], fill=color)
                elif shape_type == 'circle':
                    x = random.randint(image_size[0]//4, 3*image_size[0]//4)
                    y = random.randint(image_size[1]//4, 3*image_size[1]//4)
                    radius = random.randint(image_size[0]//8, image_size[0]//4)
                    draw.ellipse([x-radius, y-radius, x+radius, y+radius], fill=color)
                elif shape_type == 'triangle':
                    points = []
                    for _ in range(3):
                        x = random.randint(0, image_size[0])
                        y = random.randint(0, image_size[1])
                        points.append((x, y))
                    draw.polygon(points, fill=color)
                
                img_array = np.array(img)
            elif image_type == 'texture':
                # Textured pattern
                img_array = np.zeros((*image_size, 3))
                pattern = config.parameters.get('texture_pattern', 'checkerboard')
                if pattern == 'checkerboard':
                    for i in range(0, image_size[0], 10):
                        for j in range(0, image_size[1], 10):
                            if (i//10 + j//10) % 2 == 0:
                                img_array[i:i+10, j:j+10] = [255, 255, 255]
            else:
                # Default to random
                img_array = np.random.rand(*image_size, 3) * 255
            
            # Add noise
            if config.noise_level > 0:
                noise = np.random.normal(0, config.noise_level * 255, img_array.shape)
                img_array = np.clip(img_array + noise, 0, 255).astype(np.uint8)
            
            images.append(img_array)
        
        return images

class TextGenerator(SyntheticDataGenerator):
    def generate(self, config: SyntheticDataConfig) -> List[str]:
        if config.seed is not None:
            random.seed(config.seed)
        
        n_texts = config.size
        text_type = config.parameters.get('text_type', 'random')
        min_length = config.parameters.get('min_length', 10)
        max_length = config.parameters.get('max_length', 100)
        
        texts = []
        for _ in range(n_texts):
            if text_type == 'random':
                # Random text
                length = random.randint(min_length, max_length)
                text = ''.join(random.choices(string.ascii_letters + string.digits + ' ', k=length))
            elif text_type == 'lorem_ipsum':
                # Lorem ipsum
                lorem = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. "
                words = lorem.split()
                length = random.randint(min_length//5, max_length//5)
                text = ' '.join(random.choices(words, k=length))
            elif text_type == 'structured':
                # Structured text (e.g., JSON)
                data = {
                    'id': random.randint(1, 1000),
                    'name': ''.join(random.choices(string.ascii_uppercase, k=5)),
                    'value': random.random(),
                    'timestamp': datetime.now().isoformat()
                }
                text = json.dumps(data)
            else:
                # Default to random
                length = random.randint(min_length, max_length)
                text = ''.join(random.choices(string.ascii_letters + string.digits + ' ', k=length))
            
            texts.append(text)
        
        return texts

class GraphGenerator(SyntheticDataGenerator):
    def generate(self, config: SyntheticDataConfig) -> nx.Graph:
        if config.seed is not None:
            random.seed(config.seed)
        
        n_nodes = config.parameters.get('n_nodes', 10)
        graph_type = config.parameters.get('graph_type', 'random')
        edge_probability = config.parameters.get('edge_probability', 0.2)
        
        if graph_type == 'random':
            G = nx.erdos_renyi_graph(n_nodes, edge_probability, seed=config.seed)
        elif graph_type == 'scale_free':
            G = nx.barabasi_albert_graph(n_nodes, 2, seed=config.seed)
        elif graph_type == 'small_world':
            G = nx.watts_strogatz_graph(n_nodes, 4, edge_probability, seed=config.seed)
        elif graph_type == 'tree':
            G = nx.random_tree(n_nodes, seed=config.seed)
        else:
            G = nx.erdos_renyi_graph(n_nodes, edge_probability, seed=config.seed)
        
        # Add node attributes
        for node in G.nodes():
            G.nodes[node]['value'] = random.random()
            G.nodes[node]['label'] = f"Node {node}"
        
        # Add edge attributes
        for u, v in G.edges():
            G.edges[u, v]['weight'] = random.random()
        
        return G

class QuantumStateGenerator(SyntheticDataGenerator):
    def generate(self, config: SyntheticDataConfig) -> Dict[str, Any]:
        if config.seed is not None:
            np.random.seed(config.seed)
        
        n_qubits = config.parameters.get('n_qubits', 4)
        state_type = config.parameters.get('state_type', 'random')
        
        if state_type == 'random':
            # Random statevector
            statevector = random_statevector(2**n_qubits, seed=config.seed)
            state_dict = {
                'statevector': statevector.tolist(),
                'type': 'statevector',
                'n_qubits': n_qubits
            }
        elif state_type == 'ghz':
            # GHZ state
            statevector = np.zeros(2**n_qubits)
            statevector[0] = 1/np.sqrt(2)
            statevector[-1] = 1/np.sqrt(2)
            state_dict = {
                'statevector': statevector.tolist(),
                'type': 'ghz',
                'n_qubits': n_qubits
            }
        elif state_type == 'w':
            # W state
            statevector = np.zeros(2**n_qubits)
            for i in range(n_qubits):
                statevector[2**i] = 1/np.sqrt(n_qubits)
            state_dict = {
                'statevector': statevector.tolist(),
                'type': 'w',
                'n_qubits': n_qubits
            }
        else:
            # Default to random
            statevector = random_statevector(2**n_qubits, seed=config.seed)
            state_dict = {
                'statevector': statevector.tolist(),
                'type': 'random',
                'n_qubits': n_qubits
            }
        
        # Add noise if specified
        if config.noise_level > 0:
            noise = np.random.normal(0, config.noise_level, len(state_dict['statevector']))
            state_dict['statevector'] = (np.array(state_dict['statevector']) + noise).tolist()
            # Normalize
            norm = np.sqrt(np.sum(np.abs(np.array(state_dict['statevector']))**2))
            state_dict['statevector'] = (np.array(state_dict['statevector']) / norm).tolist()
        
        return state_dict
