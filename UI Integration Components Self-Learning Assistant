// src/components/SelfLearningAssistant.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Paper,
  Typography,
  Button,
  Chip,
  IconButton,
  Tooltip,
  Alert,
  LinearProgress,
  List,
  ListItem,
  ListItemText,
  ListItemSecondary,
  Divider,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Switch,
  FormControlLabel,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Badge,
  useTheme
} from '@mui/material';
import {
  SmartToy as SmartToyIcon,
  AutoAwesome as AutoAwesomeIcon,
  ThumbUp as ThumbUpIcon,
  ThumbDown as ThumbDownIcon,
  Close as CloseIcon,
  Settings as SettingsIcon,
  Info as InfoIcon,
  PlayArrow as PlayIcon,
  Stop as StopIcon
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';

interface Suggestion {
  id: string;
  rule_id: string;
  confidence: number;
  description: string;
  actions: any[];
  expected_benefit: number;
}

interface TaskStatus {
  task_id: string;
  rule_id: string;
  status: string;
  created_at: string;
  started_at?: string;
  completed_at?: string;
  error?: string;
}

const SelfLearningAssistant: React.FC = () => {
  const theme = useTheme();
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
  const [activeTasks, setActiveTasks] = useState<TaskStatus[]>([]);
  const [settingsOpen, setSettingsOpen] = useState(false);
  const [autoExecute, setAutoExecute] = useState(true);
  const [confidenceThreshold, setConfidenceThreshold] = useState(0.7);
  const [loading, setLoading] = useState(false);
  const [selectedSuggestion, setSelectedSuggestion] = useState<Suggestion | null>(null);

  // Fetch suggestions and task status
  useEffect(() => {
    // In a real app, this would fetch from the API
    const fetchSuggestions = async () => {
      setLoading(true);
      try {
        // Mock API call
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Mock suggestions
        setSuggestions([
          {
            id: '1',
            rule_id: 'auto_123',
            confidence: 0.85,
            description: 'Automate data export for weekly reports',
            actions: [
              { action_type: 'navigate', parameters: { path: '/reports' } },
              { action_type: 'click', parameters: { element: 'export_button' } },
              { action_type: 'select', parameters: { format: 'pdf' } }
            ],
            expected_benefit: 120  # seconds saved
          },
          {
            id: '2',
            rule_id: 'auto_456',
            confidence: 0.92,
            description: 'Configure system settings based on your preferences',
            actions: [
              { action_type: 'navigate', parameters: { path: '/settings' } },
              { action_type: 'adjust', parameters: { setting: 'theme', value: 'dark' } }
            ],
            expected_benefit: 30  // seconds saved
          }
        ]);
        
        // Mock active tasks
        setActiveTasks([
          {
            task_id: 'task_789',
            rule_id: 'auto_123',
            status: 'running',
            created_at: '2023-06-20T10:30:00',
            started_at: '2023-06-20T10:30:05'
          },
          {
            task_id: 'task_012',
            rule_id: 'auto_456',
            status: 'completed',
            created_at: '2023-06-20T09:15:00',
            started_at: '2023-06-20T09:15:02',
            completed_at: '2023-06-20T09:15:32'
          }
        ]);
      } catch (error) {
        console.error('Error fetching suggestions:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchSuggestions();
    
    // Set up periodic refresh
    const interval = setInterval(fetchSuggestions, 30000);  // Refresh every 30 seconds
    
    return () => clearInterval(interval);
  }, []);

  const handleAcceptSuggestion = async (suggestion: Suggestion) => {
    try {
      // In a real app, this would call the API
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Add to active tasks
      const newTask: TaskStatus = {
        task_id: `task_${Date.now()}`,
        rule_id: suggestion.rule_id,
        status: 'running',
        created_at: new Date().toISOString(),
        started_at: new Date().toISOString()
      };
      setActiveTasks(prev => [...prev, newTask]);
      
      // Remove from suggestions
      setSuggestions(prev => prev.filter(s => s.id !== suggestion.id));
      
      // Simulate task completion
      setTimeout(() => {
        setActiveTasks(prev => 
          prev.map(task => 
            task.task_id === newTask.task_id 
              ? { ...task, status: 'completed', completed_at: new Date().toISOString() }
              : task
          )
        );
        
        // Show success message
        alert('Automation completed successfully!');
      }, 3000);
    } catch (error) {
      console.error('Error accepting suggestion:', error);
    }
  };

  const handleRejectSuggestion = (suggestion: Suggestion) => {
    // Remove from suggestions
    setSuggestions(prev => prev.filter(s => s.id !== suggestion.id));
    
    // Record feedback
    // In a real app, this would call the API
    console.log(`Rejected suggestion: ${suggestion.id}`);
  };

  const handleFeedback = (task_id: string, positive: boolean) => {
    // In a real app, this would call the API
    console.log(`Feedback for task ${task_id}: ${positive ? 'positive' : 'negative'}`);
    
    // Update task status
    if (positive) {
      alert('Thank you for your feedback!');
    }
  };

  const handleCancelTask = (task_id: string) => {
    // In a real app, this would call the API
    console.log(`Cancelling task: ${task_id}`);
    
    // Update task status
    setActiveTasks(prev => 
      prev.map(task => 
        task.task_id === task_id 
          ? { ...task, status: 'cancelled', completed_at: new Date().toISOString() }
          : task
      )
    );
  };

  const getConfidenceColor = (confidence: number) => {
    if (confidence >= 0.9) return 'success';
    if (confidence >= 0.7) return 'warning';
    return 'error';
  };

  const formatTime = (timeString: string) => {
    return new Date(timeString).toLocaleTimeString();
  };

  return (
    <Paper sx={{ p: 3, mb: 3, borderRadius: 2 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <SmartToyIcon color="primary" />
          <Typography variant="h6">Self-Learning Assistant</Typography>
          <Tooltip title="Settings">
            <IconButton onClick={() => setSettingsOpen(true)}>
              <SettingsIcon />
            </IconButton>
          </Tooltip>
        </Box>
        
        <FormControlLabel
          control={<Switch
            checked={autoExecute}
            onChange={(e) => setAutoExecute(e.target.checked)}
          />}
          label="Auto-execute high-confidence suggestions"
        />
      </Box>

      {/* Suggestions Section */}
      <Typography variant="subtitle1" gutterBottom>
        Automation Suggestions
      </Typography>
      
      {loading ? (
        <LinearProgress sx={{ mb: 2 }} />
      ) : suggestions.length === 0 ? (
        <Alert severity="info" sx={{ mb: 2 }}>
          No suggestions available. Continue using the system to generate new patterns.
        </Alert>
      ) : (
        <List>
          {suggestions.map((suggestion) => (
            <React.Fragment key={suggestion.id}>
              <ListItem
                secondaryAction={
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <Chip
                      label={`${Math.round(suggestion.confidence * 100)}%`}
                      color={getConfidenceColor(suggestion.confidence)}
                      size="small"
                      sx={{ mr: 1 }}
                    />
                    <Tooltip title="View details">
                      <IconButton
                        size="small"
                        onClick={() => setSelectedSuggestion(suggestion)}
                      >
                        <InfoIcon />
                      </IconButton>
                    </Tooltip>
                    <Tooltip title="Accept suggestion">
                      <IconButton
                        size="
